//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using UnityEngine;

namespace GAF
{
	[System.Serializable]
	public class GAFBakedObject : IGAFObject
	{
		#region Members

		[HideInInspector][SerializeField] private GAFMovieClip				m_Player			= null;
		[HideInInspector][SerializeField] private GAFObjectsManager			m_Manager			= null;
		[HideInInspector][SerializeField] private int						m_ID				= -1;
		[HideInInspector][SerializeField] private int						m_AtlasElementID	= -1;
		[HideInInspector][SerializeField] private Vector3[]					m_InitialVertices	= new Vector3[4];
		[HideInInspector][SerializeField] private Vector2[]					m_UV				= new Vector2[4];
		[HideInInspector][SerializeField] private string					m_Name				= string.Empty;
		[HideInInspector][SerializeField] private ObjectType				m_Type				= ObjectType.Simple;

		[HideInInspector][SerializeField] private GAFBakedObjectController	m_Controller		= null;

		[HideInInspector][SerializeField] private bool						m_IsVisible			= true;
		[HideInInspector][SerializeField] private Material					m_CustomMaterial	= null;
		[HideInInspector][SerializeField] private Vector3					m_StatePosition		= Vector2.zero;
		[HideInInspector][SerializeField] private Vector2					m_Offset			= Vector2.zero;

		private Color32[] m_Colors			= new Color32[4];
		private Vector4[] m_ColorShift		= new Vector4[4];
		private Vector3[] m_CurrentVertices = new Vector3[4];

		private GAFObjectStateData	m_CurrentState		= null;
		private GAFAtlasData		m_TextureAtlas		= null;
		private GAFAtlasElementData	m_AtlasElement		= null;
		private GAFTexturesData		m_TextureInfo		= null;
		private Material			m_Material			= null;
		private Texture2D			m_MaskTexture		= null;
		private IGAFObject			m_Mask				= null;

		#endregion // Members

		#region Base Methods Impl

		public void initialize(ObjectType _Type, GAFMovieClip _Player, GAFObjectsManager _Manager, string _Name, int _ObjectID, int _AtlasElementID)
		{
			m_Type = _Type;
			m_Player = _Player;
			m_Manager = _Manager;
			m_Name = _Name;
			m_ID = _ObjectID;
			m_AtlasElementID = _AtlasElementID;

			m_CurrentState = new GAFObjectStateData((uint)getID());

			resetBaseData();
			initMeshData();
		}

		public void updateToState(GAFObjectStateData _State, GAFRenderProcessor _Processor, bool _Refresh)
		{
			if (m_Type != ObjectType.Mask)
			{
				updateColor(_State, _Processor, _Refresh);
				updateTransform(_State, _Processor, _Refresh);

				m_Mask = _State.maskID > 0 ? getManager().objectsDict[(int)_State.maskID] : null;
			}
			else
			{
				setCurrentState(_State);

				float scale = getMovieClip().settings.pixelsPerUnit / getMovieClip().settings.scale;
				m_StatePosition = new Vector3(_State.tX / scale, -_State.tY / scale, _State.zOrder);
			}
		}

		public void reload(GAFRenderProcessor _Processor)
		{
			m_CurrentState = new GAFObjectStateData((uint)getID());

			if (m_Controller != null)
				m_Controller.registerObject(this);

			var color = new Color32((byte)255, (byte)255, (byte)255, (byte)(0));
			for (int i = 0; i < m_Colors.Length; ++i)
				m_Colors[i] = color;

			resetBaseData();

			if (m_Type == ObjectType.Masked)
				getManager().onWillRenderObject += onWillRenderObject;
		}

		#endregion // Base Methods Impl

		#region Base Data Impl

		public int getID()
		{
			return m_ID;
		}

		public string getName()
		{
			return m_Name;
		}

		public GAFMovieClip getMovieClip()
		{
			return m_Player;
		}

		public GAFObjectsManager getManager()
		{
			return m_Manager;
		}

		public Material getCurrentMaterial()
		{
			return m_CustomMaterial == null ? m_Material : m_CustomMaterial;
		}

		public Texture2D getTexture()
		{
			return m_Type != ObjectType.Mask ?
				getMovieClip().resource.getTexture(System.IO.Path.GetFileNameWithoutExtension(getTexturesData().getFileName(getMovieClip().settings.csf))) :
				m_MaskTexture;
		}

		public int getAtlasElementID()
		{
			return m_AtlasElementID;
		}

		public GAFAtlasData getAtlasData()
		{
			return m_TextureAtlas;
		}

		public GAFAtlasElementData getAtlasElementData()
		{
			return m_AtlasElement;
		}

		public GAFTexturesData getTexturesData()
		{
			return m_TextureInfo;
		}

		public GAFObjectStateData getCurrentState()
		{
			return m_CurrentState;
		}

		public int getZOrder()
		{
			return -m_CurrentState.zOrder;
		}

		public Vector3 getLocalPosition()
		{
			return m_StatePosition + (Vector3)m_Offset;
		}

		public Vector3 getStatePosition()
		{
			return m_StatePosition;
		}

		#endregion // Base Methods Impl

		#region Manipulators Impl

		public bool getVisible()
		{
			return m_IsVisible;
		}

		public void setVisible(bool _Visible)
		{
			if (m_IsVisible != _Visible)
			{
				m_IsVisible = _Visible;

				getMovieClip().reload();
			}
		}

		public Vector2 getPositionOffset()
		{
			return m_Offset;
		}

		public void setPositionOffset(Vector2 _Offset)
		{
			if (_Offset != m_Offset)
			{
				m_Offset = _Offset;

				getMovieClip().reload();
			}
		}

		public Material getCustomMaterial()
		{
			return m_CustomMaterial;
		}

		public void setCustomMaterial(Material _Material)
		{
			m_CustomMaterial = _Material;

			if (m_CustomMaterial != null)
			{
				getMovieClip().reload();
			}
		}

		#endregion // Manipulators Impl

		#region Baked Object Interface

		public Color32[] getColors()
		{
			return m_Colors;
		}

		public Vector4[] getColorsShift()
		{
			return m_ColorShift;
		}

		public Vector3 [] getCurrentVertices()
		{
			return m_CurrentVertices;
		}

		public Vector2[] getUVs()
		{
			return m_UV;
		}

		public void setController(GAFBakedObjectController _Controller)
		{
			m_Controller = _Controller;

			if (m_Controller != null)
			{
				m_Controller.registerObject(this);
			}
		}

		public int CompareTo(object other)
		{
			return getZOrder().CompareTo(((IGAFObject)other).getZOrder());
		}

		#endregion // Baked Object Interface

		#region Implementation

		private void resetBaseData()
		{
			var movieClip	= getMovieClip();

			m_TextureAtlas	= movieClip.asset.getAtlases(movieClip.timelineID).Find(atlas => atlas.scale == movieClip.settings.scale);
			m_AtlasElement	= m_TextureAtlas.getElement((uint)getAtlasElementID());
			m_TextureInfo	= m_TextureAtlas.getAtlas(m_AtlasElement.atlasID);
			m_Material		= movieClip.resource.getMaterial(movieClip.asset, (uint)m_ID, System.IO.Path.GetFileNameWithoutExtension(getTexturesData().getFileName(movieClip.settings.csf)));

			if (m_Type == ObjectType.Mask)
				initMaskTexture();
		}

		private void initMeshData()
		{
			var movieClip	= getMovieClip();
			var element		= getAtlasElementData();
			var info		= getTexturesData();

			float scale = element.scale * getMovieClip().settings.pixelsPerUnit;
			float scaledPivotX = element.pivotX / scale;
			float scaledPivotY = element.pivotY / scale;
			float scaledWidth = element.width / scale;
			float scaledHeight = element.height / scale;

			m_InitialVertices[0] = new Vector3(-scaledPivotX, scaledPivotY - scaledHeight, 0f);
			m_InitialVertices[1] = new Vector3(-scaledPivotX, scaledPivotY, 0f);
			m_InitialVertices[2] = new Vector3(-scaledPivotX + scaledWidth, scaledPivotY, 0f);
			m_InitialVertices[3] = new Vector3(-scaledPivotX + scaledWidth, scaledPivotY - scaledHeight, 0f);

			var atlasTexture = movieClip.resource.getTexture(System.IO.Path.GetFileNameWithoutExtension(info.getFileName(movieClip.settings.csf)));
			float scaledElementLeftX = element.x * movieClip.settings.csf / atlasTexture.width;
			float scaledElementRightX = (element.x + element.width) * movieClip.settings.csf / atlasTexture.width;
			float scaledElementTopY = (atlasTexture.height - element.y * movieClip.settings.csf - element.height * movieClip.settings.csf) / atlasTexture.height;
			float scaledElementBottomY = (atlasTexture.height - element.y * movieClip.settings.csf) / atlasTexture.height;

			m_UV[0] = new Vector2(scaledElementLeftX, scaledElementTopY);
			m_UV[1] = new Vector2(scaledElementLeftX, scaledElementBottomY);
			m_UV[2] = new Vector2(scaledElementRightX, scaledElementBottomY);
			m_UV[3] = new Vector2(scaledElementRightX, scaledElementTopY);
		}

		private void updateColor(GAFObjectStateData _State, GAFRenderProcessor _Processor, bool _Refresh)
		{
			var currentState = getCurrentState();
			
			if (_Refresh ||
				currentState.alpha != _State.alpha)
			{
				if (!getVisible())
				{
					if (_Processor.objectsToRender.ContainsKey(getID()))
					{
						_Processor.state |= GAFRenderProcessor.MeshState.VertexSet;
						_Processor.objectsToRender.Remove(getID());
					}
				}
				else if (_State.alpha == 0f)
				{
					_Processor.state |= GAFRenderProcessor.MeshState.VertexSet;
					_Processor.objectsToRender.Remove(getID());
				}
				else
				{
					for (int i = 0; i < m_Colors.Length; ++i)
						m_Colors[i].a = (byte)(_State.alpha * 255f);

					if (!_Processor.objectsToRender.ContainsKey(getID()))
					{
						_Processor.state |= GAFRenderProcessor.MeshState.VertexSet;
						_Processor.objectsToRender.Add(getID(), this);
					}
					else
					{
						_Processor.state |= GAFRenderProcessor.MeshState.VertexChange;
					}
				}

				currentState.alpha = _State.alpha;
				setCurrentState(currentState);
			}

			if (_Refresh ||
				currentState.colorMatrix != _State.colorMatrix)
			{
				if (_State.colorMatrix != null)
				{
					for (int i = 0; i < m_Colors.Length; ++i)
						m_Colors[i] = _State.colorMatrix.multipliers;

					for (int i = 0; i < m_ColorShift.Length; ++i)
						m_ColorShift[i] = _State.colorMatrix.offsets;
				}
				else
				{
					for (int i = 0; i < m_Colors.Length; ++i)
					{
						m_Colors[i].r = (byte)255;
						m_Colors[i].g = (byte)255;
						m_Colors[i].b = (byte)255;
					}

					var offset = new Vector4(0f, 0f, 0f, 0f);
					for (int i = 0; i < m_ColorShift.Length; ++i)
						m_ColorShift[i] = offset;
				}

				if (getVisible())
				{
					_Processor.state |= GAFRenderProcessor.MeshState.VertexChange;
				}

				currentState.colorMatrix = _State.colorMatrix;
				setCurrentState(currentState);
			}
		}

		private void updateTransform(GAFObjectStateData _State, GAFRenderProcessor _Processor, bool _Refresh)
		{
			var currentState	= getCurrentState();
			var movieClip		= getMovieClip();

			if (currentState.alpha > 0)
			{
				if (_Refresh ||
					currentState.a != _State.a ||
					currentState.b != _State.b ||
					currentState.c != _State.c ||
					currentState.d != _State.d ||
					currentState.tX != _State.tX ||
					currentState.tY != _State.tY ||
					currentState.zOrder != _State.zOrder)
				{
					if (currentState.zOrder != _State.zOrder)
					{
						_Processor.state |= GAFRenderProcessor.MeshState.VertexSet;
					}
					else
					{
						_Processor.state |= GAFRenderProcessor.MeshState.VertexChange;
					}

					_Processor.objectsToRender[getID()] = this;

					float scale = movieClip.settings.pixelsPerUnit / movieClip.settings.scale;

					Matrix4x4 _transform = Matrix4x4.identity;
					_transform[0, 0] =  _State.a;
					_transform[0, 1] = -_State.c;
					_transform[1, 0] = -_State.b;
					_transform[1, 1] =  _State.d;
					_transform[0, 3] =  _State.tX / scale + m_Offset.x;
					_transform[1, 3] = -_State.tY / scale + m_Offset.y;
					_transform[2, 3] =  _State.zOrder;

					m_StatePosition = new Vector3(_State.tX / scale, -_State.tY / scale, _State.zOrder);

					for (int i = 0; i < m_InitialVertices.Length; i++)
					{
						var vertex = m_InitialVertices[i];
						m_CurrentVertices[i] = _transform.MultiplyPoint3x4(vertex);
					}

					currentState.tX = _State.tY;
					currentState.tY = _State.tY;
					currentState.zOrder = _State.zOrder;
					currentState.a = _State.a;
					currentState.b = _State.b;
					currentState.c = _State.c;
					currentState.d = _State.d;

					setCurrentState(currentState);
				}
			}
		}

		private void onWillRenderObject()
		{
			var movieClip = getMovieClip();

			if (movieClip != null &&
				movieClip.asset != null &&
				movieClip.asset.isLoaded &&
				movieClip.resource != null &&
				movieClip.resource.isReady &&
				getCurrentMaterial() != null)
			{
				if (m_Mask != null &&
					m_Mask.getCurrentState() != null &&
					m_Mask.getCurrentState().alpha > 0 &&
					m_Mask.getTexture() != null &&
					m_Mask.getAtlasElementData() != null)
				{
					applyMask();
				}
				else
				{
					getCurrentMaterial().SetTexture("_MaskMap", null);
				}
			}
		}

		private void applyMask()
		{
			var movieClip = getMovieClip();

			Matrix4x4 maskTransform = Matrix4x4.identity;
			maskTransform.m00 = m_Mask.getCurrentState().a;
			maskTransform.m01 = m_Mask.getCurrentState().c;
			maskTransform.m10 = m_Mask.getCurrentState().b;
			maskTransform.m11 = m_Mask.getCurrentState().d;

#if GAF_USING_TK2D
			float screenHeight 		= 0;
			float screenWidth  		= 0;
			Vector2 cameraPosShift	= Vector2.zero;
		
			tk2dCamera tk2d_camera = Camera.current.GetComponent<tk2dCamera>();
			if (tk2d_camera != null)
			{
				tk2dCameraSettings cameraSettings = tk2d_camera.CameraSettings;
				if (cameraSettings.orthographicType == tk2dCameraSettings.OrthographicType.PixelsPerMeter)
					screenHeight = tk2d_camera.nativeResolutionHeight / cameraSettings.orthographicPixelsPerMeter;
				else
					screenHeight = tk2d_camera.CameraSettings.orthographicSize * 2;

				screenWidth  	= Camera.current.aspect * screenHeight;
				cameraPosShift	= Camera.current.transform.position - new Vector3(screenWidth / 2f, -screenHeight / 2f);
			}
			else
			{
				screenHeight 	= Camera.current.orthographicSize * 2;
				screenWidth  	= Camera.current.aspect * screenHeight;
				cameraPosShift	= Camera.current.transform.position - new Vector3(screenWidth / 2f, -screenHeight / 2f);
			}
#else
			float screenHeight = Camera.current.orthographicSize * 2;
			float screenWidth = Camera.current.aspect * screenHeight;
			Vector2 cameraPosShift = Camera.current.transform.position - new Vector3(screenWidth / 2f, -screenHeight / 2f);
#endif // GAF_USING_TK2D

			float scaleX = Mathf.Sqrt((maskTransform.m00 * maskTransform.m00) + (maskTransform.m01 * maskTransform.m01));
			float scaleY = Mathf.Sqrt((maskTransform.m11 * maskTransform.m11) + (maskTransform.m10 * maskTransform.m10));

			float scale = movieClip.settings.pixelsPerUnit * m_Mask.getAtlasElementData().scale * movieClip.settings.csf;
			float sizeXUV = (float)screenWidth / (m_Mask.getTexture().width / scale * scaleX * movieClip.transform.localScale.x * Camera.current.aspect);
			float sizeYUV = (float)screenHeight / (m_Mask.getTexture().height / scale * scaleY * movieClip.transform.localScale.y);

			float maskWidth = (float)m_Mask.getTexture().width / movieClip.settings.csf;
			float maskHeight = (float)m_Mask.getTexture().height / movieClip.settings.csf;

			float pivotX = m_Mask.getAtlasElementData().pivotX / maskWidth;
			float pivotY = (maskHeight - m_Mask.getAtlasElementData().pivotY) / maskHeight;

			float moveX = (-m_Mask.getLocalPosition().x - getManager().transform.position.x + cameraPosShift.x) / screenWidth;
			float moveY = -1f - (m_Mask.getLocalPosition().y + getManager().transform.position.y - cameraPosShift.y) / screenHeight;

			Matrix4x4 _transform = Matrix4x4.identity;
			_transform *= Matrix4x4.TRS(new Vector3(pivotX, pivotY, 0f), Quaternion.identity, Vector3.one);
			_transform *= Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(sizeXUV, sizeYUV, 1f));
			_transform *= Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(0f, 0f, -movieClip.transform.localRotation.eulerAngles.z), Vector3.one);
			_transform *= maskTransform;
			_transform *= Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(1f / scaleX, 1f / scaleY, 1f));
			_transform *= Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(Camera.current.aspect, 1f, 1f));
			_transform *= Matrix4x4.TRS(new Vector3(moveX, moveY, 0f), Quaternion.identity, Vector3.one);

			getCurrentMaterial().SetMatrix("_TransformMatrix", _transform);
			getCurrentMaterial().SetTexture("_MaskMap", m_Mask.getTexture());
		}

		private void initMaskTexture()
		{
			var movieClip = getMovieClip();
			var element = getAtlasElementData();
			var info = getTexturesData();

			int csf = (int)movieClip.settings.csf;

			m_MaskTexture = new Texture2D(
				  (int)(element.width * csf)
				, (int)(element.height * csf)
				, TextureFormat.ARGB32
				, false);

			Color[] textureColor = m_MaskTexture.GetPixels();
			for (uint i = 0; i < textureColor.Length; ++i)
				textureColor[i] = Color.black;

			m_MaskTexture.SetPixels(textureColor);
			m_MaskTexture.Apply();

			Texture2D atlasTexture = movieClip.resource.getTexture(System.IO.Path.GetFileNameWithoutExtension(info.getFileName(csf)));
			Color[] maskTexturePixels = atlasTexture.GetPixels(
				  (int)(element.x * csf)
				, (int)(atlasTexture.height - element.y * csf - element.height * csf)
				, (int)(element.width * csf)
				, (int)(element.height * csf));

			m_MaskTexture.SetPixels(
				  0
				, 0
				, (int)(element.width * csf)
				, (int)(element.height * csf)
				, maskTexturePixels);

			m_MaskTexture.Apply(true);

			m_MaskTexture.filterMode = FilterMode.Bilinear;
			m_MaskTexture.wrapMode = TextureWrapMode.Clamp;

			m_MaskTexture.Apply();
		}

		private void setCurrentState(GAFObjectStateData _State)
		{
			m_CurrentState = _State;
		}

		#endregion // Implementation
	}
}