//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace GAF
{
	[AddComponentMenu("")]
	[RequireComponent(typeof(MeshFilter))]
	[RequireComponent(typeof(MeshRenderer))]
	[ExecuteInEditMode]
	#if UNITY_4_5
	[DisallowMultipleComponent]
	#endif
	public class GAFObject : MonoBehaviour, IGAFObject
	{
		#region Members

		protected static readonly Vector3[] normals		= new Vector3[4] { new Vector3(0f, 0f, -1f), new Vector3(0f, 0f, -1f), new Vector3(0f, 0f, -1f), new Vector3(0f, 0f, -1f) };
		protected static readonly int[]		triangles	= new int[6] { 2, 0, 1, 3, 0, 2 };

		[HideInInspector][SerializeField] private GAFMovieClip  	m_Player 			= null;
		[HideInInspector][SerializeField] private GAFObjectsManager	m_Manager			= null;
		[HideInInspector][SerializeField] private int				m_ID 				= -1;
		[HideInInspector][SerializeField] private int				m_AtlasElementID	= -1;
		[HideInInspector][SerializeField] private Vector3[]			m_InitialVertices	= new Vector3[4];
		[HideInInspector][SerializeField] private Vector2[]			m_UV				= new Vector2[4];
		[HideInInspector][SerializeField] private MeshFilter		m_Filter			= null;
		[HideInInspector][SerializeField] private MeshRenderer		m_MeshRenderer		= null;

		[HideInInspector][SerializeField] private bool				m_IsVisible			= true;
		[HideInInspector][SerializeField] private Material			m_CustomMaterial	= null;
		[HideInInspector][SerializeField] private Vector3			m_StatePosition		= Vector3.zero;
		[HideInInspector][SerializeField] private Vector2			m_Offset			= Vector2.zero;

		private Color32[] m_Colors		= null;
		private Vector4[] m_ColorShift	= null;
		
		private GAFObjectStateData	m_CurrentState	= null;
		private GAFAtlasData 		m_TextureAtlas	= null;
		private GAFAtlasElementData m_AtlasElement	= null;
		private GAFTexturesData 	m_TextureInfo	= null;
		private Material			m_Material		= null;
	
		#endregion // Members

		#region Properties

		public MeshFilter filter
		{
			get
			{
				return m_Filter;
			}
		}

		new public MeshRenderer renderer
		{
			get
			{
				return m_MeshRenderer;
			}
		}

		#endregion // Properties

		#region Base Methods Impl

		public virtual void initialize(ObjectType _Type, GAFMovieClip _Player, GAFObjectsManager _Manager, string _Name, int _ObjectID, int _AtlasElementID)
		{
			m_Player = _Player;
			m_Manager = _Manager;
			name = _Name;
			m_ID = _ObjectID;
			m_AtlasElementID = _AtlasElementID;
			m_Filter = GetComponent<MeshFilter>();
			m_MeshRenderer = GetComponent<MeshRenderer>();

			m_CurrentState = new GAFObjectStateData((uint)getID());

			resetBaseData();
			initMeshData();
		}

		public virtual void updateToState(GAFObjectStateData _State, GAFRenderProcessor _Processor, bool _Refresh)
		{
			transform.localRotation = Quaternion.identity;
			transform.localScale = Vector3.one;
			gameObject.SetActive(_State.alpha > 0);

			updateColor(_State, _Refresh);
			updateTransform(_State, _Refresh);
		}

		public virtual void reload(GAFRenderProcessor _Processor)
		{
			m_CurrentState = new GAFObjectStateData((uint)getID());

			resetBaseData();
			resetMesh();
			resetRenderer();

			updateToState(getCurrentState(), _Processor, true);
		}

		#endregion // Base Methods Impl

		#region Base Data Impl

		public int getID()
		{
			return m_ID;
		}

		public string getName()
		{
			return name;
		}

		public GAFMovieClip getMovieClip()
		{
			return m_Player;
		}

		public GAFObjectsManager getManager()
		{
			return m_Manager;
		}

		public Material getCurrentMaterial()
		{
			return m_CustomMaterial == null ? m_Material : m_CustomMaterial;
		}

		public virtual Texture2D getTexture()
		{
			return getMovieClip().resource.getTexture(System.IO.Path.GetFileNameWithoutExtension(getTexturesData().getFileName(getMovieClip().settings.csf)));
		}

		public int getAtlasElementID()
		{
			return m_AtlasElementID;
		}

		public GAFAtlasData getAtlasData()
		{
			return m_TextureAtlas;
		}

		public GAFAtlasElementData getAtlasElementData()
		{
			return m_AtlasElement;
		}

		public GAFTexturesData getTexturesData()
		{
			return m_TextureInfo;
		}

		public GAFObjectStateData getCurrentState()
		{
			return m_CurrentState;
		}

		public int getZOrder()
		{
			return -getCurrentState().zOrder;
		}

		public Vector3 getLocalPosition()
		{
			return m_StatePosition + (Vector3) m_Offset;
		}

		public Vector3 getStatePosition()
		{
			return m_StatePosition;
		}

		#endregion // Base Data Impl

		#region Manipulators Impl

		public bool getVisible()
		{
			return m_IsVisible;
		}

		public void setVisible(bool _Visible)
		{
			if (m_IsVisible != _Visible)
			{
				m_IsVisible = _Visible;
				renderer.enabled = _Visible;
			}
		}

		public Vector2 getPositionOffset()
		{
			return m_Offset;
		}

		public void setPositionOffset(Vector2 _Offset)
		{
			if (_Offset != m_Offset)
			{
				m_Offset = _Offset;

				getMovieClip().reload();
			}
		}

		public Material getCustomMaterial()
		{
			return m_CustomMaterial;
		}

		public void setCustomMaterial(Material _Material)
		{
			m_CustomMaterial = _Material;

			if (m_CustomMaterial != null)
			{
				getMovieClip().reload();
			}
		}

		#endregion Manipulators Impl

		#region Object Interface

		public int CompareTo(object other)
		{
			return getZOrder().CompareTo(((IGAFObject)other).getZOrder());
		}

		#endregion // Object Interface

		#region Implementation

		protected virtual void initMeshData()
		{
			var movieClip	= getMovieClip();
			var element		= getAtlasElementData();
			var info		= getTexturesData();

			float scale = element.scale * getMovieClip().settings.pixelsPerUnit;
			float scaledPivotX = element.pivotX / scale;
			float scaledPivotY = element.pivotY / scale;
			float scaledWidth = element.width / scale;
			float scaledHeight = element.height / scale;

			m_InitialVertices[0] = new Vector3(-scaledPivotX, scaledPivotY - scaledHeight, 0f);
			m_InitialVertices[1] = new Vector3(-scaledPivotX, scaledPivotY, 0f);
			m_InitialVertices[2] = new Vector3(-scaledPivotX + scaledWidth, scaledPivotY, 0f);
			m_InitialVertices[3] = new Vector3(-scaledPivotX + scaledWidth, scaledPivotY - scaledHeight, 0f);

			var atlasTexture = movieClip.resource.getTexture(System.IO.Path.GetFileNameWithoutExtension(info.getFileName(movieClip.settings.csf)));
			float scaledElementLeftX = element.x * movieClip.settings.csf / atlasTexture.width;
			float scaledElementRightX = (element.x + element.width) * movieClip.settings.csf / atlasTexture.width;
			float scaledElementTopY = (atlasTexture.height - element.y * movieClip.settings.csf - element.height * movieClip.settings.csf) / atlasTexture.height;
			float scaledElementBottomY = (atlasTexture.height - element.y * movieClip.settings.csf) / atlasTexture.height;

			m_UV[0] = new Vector2(scaledElementLeftX, scaledElementTopY);
			m_UV[1] = new Vector2(scaledElementLeftX, scaledElementBottomY);
			m_UV[2] = new Vector2(scaledElementRightX, scaledElementBottomY);
			m_UV[3] = new Vector2(scaledElementRightX, scaledElementTopY);
		}

		protected virtual void resetRenderer()
		{
			var movieClip = getMovieClip();

			renderer.sharedMaterial = movieClip.resource.getMaterial(movieClip.asset, (uint)getID(), System.IO.Path.GetFileNameWithoutExtension(getTexturesData().getFileName(movieClip.settings.csf)));
			renderer.castShadows	= false;
			renderer.receiveShadows = false;
			renderer.sortingLayerID = movieClip.settings.spriteLayerID;
			renderer.sortingOrder	= movieClip.settings.spriteLayerValue;
		}

		protected virtual void resetBaseData()
		{
			m_TextureAtlas = getMovieClip().asset.getAtlases(getMovieClip().timelineID).Find(atlas => atlas.scale == getMovieClip().settings.scale);
			m_AtlasElement = getAtlasData().getElement((uint)getAtlasElementID());
			m_TextureInfo = getAtlasData().getAtlas(getAtlasElementData().atlasID);
			m_Material = getMovieClip().resource.getMaterial(getMovieClip().asset, (uint)getID(), System.IO.Path.GetFileNameWithoutExtension(getTexturesData().getFileName(getMovieClip().settings.csf)));

			var color = new Color32((byte)255, (byte)255, (byte)255, (byte)255);

			m_Colors = new Color32[4] { color, color, color, color };
			m_ColorShift = new Vector4[4];
		}

		protected virtual void resetMesh()
		{
			Mesh mesh = new Mesh();
			mesh.name = name;

			mesh.vertices	= m_InitialVertices;
			mesh.uv			= m_UV;
			mesh.triangles	= triangles;
			mesh.normals	= normals;
			mesh.colors32	= m_Colors;

			filter.mesh = mesh;
		}

		protected virtual void updateColor(GAFObjectStateData _State, bool _Refresh)
		{
			var setColors = false;
			var setColorsShift = false;

			var currentState = getCurrentState();
			if (currentState.alpha != _State.alpha ||
				_Refresh)
			{
				if (_State.alpha == 0f)
				{
					renderer.enabled = false;
				}
				else
				{
					renderer.enabled = getVisible();

					for (int i = 0; i < m_Colors.Length; ++i)
						m_Colors[i].a = (byte)(_State.alpha * 255f);
				}

				setColors = true;

				currentState.alpha = _State.alpha;
				setCurrentState(currentState);
			}

			if (currentState.colorMatrix != _State.colorMatrix ||
				_Refresh)
			{
				if (_State.colorMatrix != null)
				{
					for (int i = 0; i < m_Colors.Length; ++i)
						m_Colors[i] = _State.colorMatrix.multipliers;

					for (int i = 0; i < m_ColorShift.Length; ++i)
						m_ColorShift[i] = _State.colorMatrix.offsets;
				}
				else
				{
					for (int i = 0; i < m_Colors.Length; ++i)
					{
						m_Colors[i].r = (byte)255;
						m_Colors[i].g = (byte)255;
						m_Colors[i].b = (byte)255;
					}

					var offset = new Vector4(0f, 0f, 0f, 0f);
					for (int i = 0; i < m_ColorShift.Length; ++i)
						m_ColorShift[i] = offset;
				}

				setColors = true;
				setColorsShift = true;

				currentState.colorMatrix = _State.colorMatrix;
				setCurrentState(currentState);
			}

			if (setColors)
				filter.sharedMesh.colors32 = m_Colors;

			if (setColorsShift)
				filter.sharedMesh.tangents = m_ColorShift;
		}

		protected virtual void updateTransform(GAFObjectStateData _State, bool _Refresh)
		{
			transform.localRotation = Quaternion.identity;
			transform.localScale	= Vector3.one;

			var currentState	= getCurrentState();
			var movieClip		= getMovieClip();

			if (currentState.alpha > 0)
			{
				if (_Refresh ||
					currentState.tX != _State.tX ||
					currentState.tY != _State.tY ||
					currentState.zOrder != _State.zOrder)
				{
					float scale = movieClip.settings.pixelsPerUnit / movieClip.settings.scale;

					m_StatePosition = new Vector3((_State.tX) / scale, (-_State.tY) / scale, _State.zOrder);
					transform.localPosition = m_StatePosition + (Vector3) m_Offset;

					currentState.tX		= _State.tX;
					currentState.tY		= _State.tY;
					currentState.zOrder = _State.zOrder;

					setCurrentState(currentState);
				}

				if (_Refresh ||
					currentState.a != _State.a ||
					currentState.b != _State.b ||
					currentState.c != _State.c ||
					currentState.d != _State.d)
				{
					Matrix4x4 _transform = Matrix4x4.identity;
					_transform[0, 0] = _State.a;
					_transform[0, 1] = -_State.c;
					_transform[1, 0] = -_State.b;
					_transform[1, 1] = _State.d;

					Vector3[] vertices = new Vector3[m_InitialVertices.Length];
					for (int i = 0; i < vertices.Length; i++)
						vertices[i] = _transform * m_InitialVertices[i];

					filter.sharedMesh.vertices = vertices;
					filter.sharedMesh.RecalculateBounds();

					currentState.a = _State.a;
					currentState.b = _State.b;
					currentState.c = _State.c;
					currentState.d = _State.d;

					setCurrentState(currentState);
				}
			}
		}

		protected void setCurrentState(GAFObjectStateData _State)
		{
			m_CurrentState = _State;
		}

		protected void setStatePosition(Vector3 _StatePosition)
		{
			m_StatePosition = _StatePosition;
		}

		#endregion // Implementation
	}
}